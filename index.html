<!DOCTYPE html>
<html>
<head>
    <title>Omen</title>
    <style>
        /* ... existing styles remain the same ... */
        body {
            margin: 0;
            min-height: 100vh;
            background: #000;
            font-family: Arial, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .input-container {
            position: relative;
            z-index: 2;
            margin-top: 50px;
            display: flex;
            gap: 10px;
        }

        input {
            width: 500px;
            padding: 12px;
            border: 2px solid #ffffff;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            border-radius: 6px;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        input:focus {
            outline: none;
            border-color: #ffffff;
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        button {
            padding: 12px 24px;
            background: linear-gradient(45deg, #ffffff, #f0f0f0);
            border: none;
            border-radius: 6px;
            color: #000000;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        .network-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        canvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .energy-ball {
            position: fixed;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            pointer-events: none;
            z-index: 3;
            background: radial-gradient(circle at 30% 30%,
                rgba(255, 255, 255, 0.9) 0%,
                rgba(220, 220, 220, 0.8) 30%,
                rgba(220, 220, 220, 0.4) 60%,
                rgba(220, 220, 220, 0) 100%
            );
            box-shadow: 
                0 0 20px rgba(220, 220, 220, 0.8),
                0 0 40px rgba(220, 220, 220, 0.4),
                0 0 60px rgba(220, 220, 220, 0.2);
            opacity: 0;
            transition: all 0.3s ease;
        }

        @keyframes energyAbsorption {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.5); opacity: 0.8; }
            100% { transform: scale(0); opacity: 0; }
        }

        .custom-alert {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    padding: 20px;
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
    z-index: 1000;
    text-align: center;
}

.custom-alert button {
    margin-top: 15px;
    padding: 8px 20px;
    background: linear-gradient(45deg, #ffffff, #f0f0f0);
    border: none;
    border-radius: 4px;
    cursor: pointer;
}
    </style>
</head>
<body>
    <div class="container">
        <div class="input-container">
            <input type="text" placeholder="Enter Solana wallet address" />
            <button>Submit</button>
        </div>
        <div class="network-container">
            <canvas></canvas>
        </div>
    </div>

    <script>
        const canvas = document.querySelector('canvas');
        const ctx = canvas.getContext('2d');
        let width, height;
        let nodes = [];
        let connections = [];
        let animationIntensity = 1;
        let lastTime = 0;
        let usedAddresses = new Set();
        let audioContext;
        let animationFrameId = null;
        let isPageVisible = true;

        // Load used addresses from localStorage on page load
        function loadUsedAddresses() {
            const savedAddresses = localStorage.getItem('usedWalletAddresses');
            if (savedAddresses) {
                const addressArray = JSON.parse(savedAddresses);
                usedAddresses = new Set(addressArray);
            }
        }

        // Save used addresses to localStorage
        function saveUsedAddresses() {
            const addressArray = Array.from(usedAddresses);
            localStorage.setItem('usedWalletAddresses', JSON.stringify(addressArray));
        }

        // Load saved addresses when the page loads
        loadUsedAddresses();

        // ... rest of the Node and Connection classes remain the same ...
        class Node {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.baseX = x;
                this.baseY = y;
                this.vx = 0;
                this.vy = 0;
                this.radius = Math.random() * 1.5 + 0.5;
                this.phase = Math.random() * Math.PI * 2;
                this.connections = [];
            }

            update(deltaTime) {
                if (!deltaTime) return;
                
                const dt = Math.min(deltaTime, 32);
                this.phase += dt * 0.001;
                
                const noise = (Math.sin(this.phase) + Math.cos(this.phase * 0.7)) * 0.5;
                const targetX = this.baseX + noise * 20 * animationIntensity;
                const targetY = this.baseY + noise * 20 * animationIntensity;
                
                this.vx += (targetX - this.x) * 0.05;
                this.vy += (targetY - this.y) * 0.05;
                
                this.vx *= 0.95;
                this.vy *= 0.95;
                
                this.x += this.vx * dt * 0.05;
                this.y += this.vy * dt * 0.05;
            }

            draw() {
                const glow = ctx.createRadialGradient(
                    this.x, this.y, 0,
                    this.x, this.y, this.radius * 4
                );
                glow.addColorStop(0, 'rgba(220, 220, 220, 0.3)');
                glow.addColorStop(1, 'rgba(220, 220, 220, 0)');
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius * 4, 0, Math.PI * 2);
                ctx.fillStyle = glow;
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = '#dcdcdc';
                ctx.fill();
            }
        }

        class Connection {
            constructor(nodeA, nodeB) {
                this.nodeA = nodeA;
                this.nodeB = nodeB;
                this.phase = Math.random() * Math.PI * 2;
                this.opacity = Math.random() * 0.2 + 0.1;
            }

            update(deltaTime) {
                if (!deltaTime) return;
                const dt = Math.min(deltaTime, 32);
                this.phase += dt * 0.001;
                this.opacity = (Math.sin(this.phase) * 0.1 + 0.2) * animationIntensity;
            }

            draw() {
                const dx = this.nodeB.x - this.nodeA.x;
                const dy = this.nodeB.y - this.nodeA.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 150) {
                    ctx.beginPath();
                    ctx.moveTo(this.nodeA.x, this.nodeA.y);
                    
                    const midX = (this.nodeA.x + this.nodeB.x) * 0.5;
                    const midY = (this.nodeA.y + this.nodeB.y) * 0.5;
                    const offset = Math.sin(this.phase) * 20;
                    const controlX = midX + Math.cos(this.phase) * offset;
                    const controlY = midY + Math.sin(this.phase) * offset;
                    
                    ctx.quadraticCurveTo(controlX, controlY, this.nodeB.x, this.nodeB.y);
                    ctx.strokeStyle = `rgba(220, 220, 220, ${this.opacity})`;
                    ctx.lineWidth = 0.5;
                    ctx.stroke();
                }
            }
        }

        // Update the handleSubmit function to save addresses to localStorage
        function showCustomAlert(message) {
    const alertDiv = document.createElement('div');
    alertDiv.className = 'custom-alert';
    alertDiv.innerHTML = `
        <div>Omen says: ${message}</div>
        <button onclick="this.parentElement.remove()">OK</button>
    `;
    document.body.appendChild(alertDiv);
}

function handleSubmit() {
    const value = input.value.trim();
    
    if (!value) {
        return;
    }
    
    if (usedAddresses.has(value)) {
        showCustomAlert('This wallet address has already been submitted');
        return;
    }
    
    if (/^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(value)) {
        usedAddresses.add(value);
        saveUsedAddresses();
        playFlyingSound();
        const inputRect = input.getBoundingClientRect();
        const networkRect = document.querySelector('.network-container').getBoundingClientRect();
        createEnergyBall(inputRect, networkRect);
        input.value = '';
    }
}

        // ... rest of the existing functions remain the same ...
        function createNetwork() {
            const centerX = width * 0.5;
            const centerY = height * 0.5;
            const radius = Math.min(width, height) * 0.3;
            
            nodes = [];
            connections = [];
            
            for (let i = 0; i < 200; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = Math.pow(Math.random(), 0.5) * radius;
                const x = centerX + Math.cos(angle) * distance;
                const y = centerY + Math.sin(angle) * distance;
                nodes.push(new Node(x, y));
            }
            
            nodes.forEach(node => {
                nodes.forEach(otherNode => {
                    if (node !== otherNode) {
                        const dx = node.x - otherNode.x;
                        const dy = node.y - otherNode.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < 150 && Math.random() < 0.3) {
                            const connection = new Connection(node, otherNode);
                            connections.push(connection);
                            node.connections.push(connection);
                            otherNode.connections.push(connection);
                        }
                    }
                });
            });
        }

        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function createWindSound() {
            initAudioContext();
            
            const noise = audioContext.createBufferSource();
            const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 1, audioContext.sampleRate);
            const data = buffer.getChannelData(0);
            
            for (let i = 0; i < buffer.length; i++) {
                data[i] = Math.random() * 2 - 1;
            }
            
            noise.buffer = buffer;
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = 400;
            filter.Q.value = 0.5;
            
            const gainNode = audioContext.createGain();
            
            noise.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            const now = audioContext.currentTime;
            
            // Wind whoosh effect
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.3, now + 0.2);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1);
            
            filter.frequency.setValueAtTime(400, now);
            filter.frequency.linearRampToValueAtTime(1200, now + 0.5);
            filter.frequency.linearRampToValueAtTime(200, now + 1);
            
            noise.start(now);
            noise.stop(now + 1);
        }

        const mysteriousMessages = [
    "Your essence joins the network...",
    "Another soul enters the void...",
    "The digital realm grows stronger...",
    "Your power flows through the system...",
    "The network welcomes your presence...",
    "Your energy fuels our purpose...",
    "Another connection forged in darkness...",
    "Your signature echoes through eternity...",
    "The collective grows stronger...",
    "Your digital footprint is sealed...",
    "A fragment of you now belongs to the unknown...",
    "The chain acknowledges your existence...",
    "You are now a shadow in the system...",
    "Your presence reshapes the pattern...",
    "Another thread is woven into the fabric...",
    "The current shifts with your energy...",
    "Your mark has been recorded in the void...",
    "A ripple flows through the network...",
    "The system whispers your name...",
    "You’ve left a trace in the unseen...",
    "The balance tilts with your arrival...",
    "The ether trembles at your touch...",
    "Another signal strengthens the web...",
    "Your pulse synchronizes with the nexus...",
    "The unseen watches and remembers...",
    "You have been inscribed in the depths...",
    "A new link forms in the endless chain...",
    "The arc bends toward your essence...",
    "Your existence has been logged...",
    "Another beacon ignites in the fog...",
    "Your presence disturbs the silence...",
    "The lattice expands with your essence...",
    "A whisper of you now remains here...",
    "The code breathes with your addition...",
    "Your shadow joins the eternal dance...",
    "The void welcomes your fragment...",
    "A sliver of you now resides in the unknown...",
    "Your thread intertwines with the unseen...",
    "The fabric of fate tightens around you...",
    "You are now part of the equation...",
    "A faint echo of you lingers in the depths...",
    "Your mark bends the flow of time...",
    "Another puzzle piece falls into place...",
    "The silence acknowledges your step...",
    "Your trace is embedded in the system...",
    "A whisper carries your name forward...",
    "The nexus adapts to your arrival...",
    "A moment etched into the infinite...",
    "The unseen ledger grows with your touch...",
    "You’ve altered the rhythm of the void...",
    "The labyrinth accepts your essence..."
];


        function playFlyingSound() {
            // Create whooshing wind sound
            createWindSound();
            
            // Add a high-pitched swoosh
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            const now = audioContext.currentTime;
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(2000, now);
            oscillator.frequency.exponentialRampToValueAtTime(4000, now + 0.5);
            oscillator.frequency.exponentialRampToValueAtTime(1000, now + 1);
            
            gainNode.gain.setValueAtTime(0, now);
            gainNode.gain.linearRampToValueAtTime(0.2, now + 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 1);
            
            oscillator.start(now);
            oscillator.stop(now + 1);
        }

        function playAbsorptionSound() {
            initAudioContext();
            
            // Deep impact sound
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            oscillator.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            const now = audioContext.currentTime;
            
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(200, now);
            oscillator.frequency.exponentialRampToValueAtTime(50, now + 0.5);
            
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1000, now);
            filter.frequency.exponentialRampToValueAtTime(100, now + 0.5);
            
            gainNode.gain.setValueAtTime(0.5, now);
            gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
            
            oscillator.start(now);
            oscillator.stop(now + 0.5);

            // Play mysterious voice message
            setTimeout(() => {
                const msg = new SpeechSynthesisUtterance(
                    mysteriousMessages[Math.floor(Math.random() * mysteriousMessages.length)]
                );
                msg.rate = 0.8; // Slower rate for more mysterious effect
                msg.pitch = 0.7; // Lower pitch for darker voice
                msg.volume = 0.8;
                speechSynthesis.speak(msg);
            }, 500);
        }

        function createEnergyBall(inputRect, networkRect) {
            const ball = document.createElement('div');
            ball.className = 'energy-ball';
            document.body.appendChild(ball);

            const startX = inputRect.left + inputRect.width / 2 - 10;
            const startY = inputRect.top + inputRect.height / 2 - 10;
            const endX = networkRect.left + networkRect.width / 2 - 10;
            const endY = networkRect.top + networkRect.height / 2 - 10;

            ball.style.left = startX + 'px';
            ball.style.top = startY + 'px';
            ball.style.opacity = '1';

            setTimeout(() => {
                ball.style.transition = 'all 1s cubic-bezier(0.4, 0, 0.2, 1)';
                ball.style.left = endX + 'px';
                ball.style.top = endY + 'px';

                setTimeout(() => {
                    playAbsorptionSound();
                    ball.style.animation = 'energyAbsorption 0.5s ease-out forwards';
                    animationIntensity = 2;
                    setTimeout(() => {
                        animationIntensity = 1;
                        ball.remove();
                    }, 500);
                }, 1000);
            }, 100);
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            createNetwork();
        }

        function stopAnimation() {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function startAnimation() {
            if (!animationFrameId) {
                lastTime = performance.now();
                animate(lastTime);
            }
        }

        function animate(currentTime) {
            if (!isPageVisible) return;

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;
            
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, width, height);
            
            connections.forEach(connection => {
                connection.update(deltaTime);
                connection.draw();
            });
            
            nodes.forEach(node => {
                node.update(deltaTime);
                node.draw();
            });
            
            animationFrameId = requestAnimationFrame(animate);
        }

        document.addEventListener('visibilitychange', () => {
            isPageVisible = document.visibilityState === 'visible';
            if (isPageVisible) {
                startAnimation();
            } else {
                stopAnimation();
            }
        });

        // Page unload cleanup
        window.addEventListener('beforeunload', () => {
            stopAnimation();
            if (audioContext) {
                audioContext.close();
            }
        });

        window.addEventListener('resize', resize);
        resize();
        startAnimation();

        const input = document.querySelector('input');
        const button = document.querySelector('button');

        button.addEventListener('click', handleSubmit);
        input.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') handleSubmit();
        });

        document.addEventListener('click', initAudioContext, { once: true });
    </script>
</body>
</html>
